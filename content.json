{"meta":{"title":"MrDust Blog","subtitle":"love is love","description":"","author":"MrDust","url":"http://blog.mrdust.com","root":"/"},"pages":[{"title":"about","date":"2020-04-08T09:12:49.000Z","updated":"2020-04-08T09:12:49.818Z","comments":true,"path":"about/index.html","permalink":"http://blog.mrdust.com/about/index.html","excerpt":"","text":""},{"title":"MrDust","date":"2020-04-08T09:28:15.000Z","updated":"2020-04-08T09:28:48.922Z","comments":true,"path":"tags/index.html","permalink":"http://blog.mrdust.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-04-08T09:28:57.000Z","updated":"2020-04-08T09:28:57.251Z","comments":true,"path":"categories/index.html","permalink":"http://blog.mrdust.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"20200414工作日志","slug":"20200414工作日志","date":"2020-04-14T09:38:54.000Z","updated":"2020-04-14T09:52:50.815Z","comments":true,"path":"2020/04/14/20200414工作日志/","link":"","permalink":"http://blog.mrdust.com/2020/04/14/20200414%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/","excerpt":"","text":"20200414工作日志1. 建筑管理 – 建筑数据采集页面补充1.1 查看详情查看详情 是一个dialog ，除了dialog以外还涉及了tage，from,联网加载下拉选择框等。 1.2 tage1&lt;avue-tabs :option&#x3D;&quot;tabsOption&quot; @change&#x3D;&quot;handleChange&quot;&gt;&lt;&#x2F;avue-tabs&gt; 其中：option是配置文件。可以使用@change回调函数来控制页面切换； 1234type:&#123;prop: 'tab1'&#125;,handleChange(column) &#123; this.type = column;&#125; 利用 v-else-if 指令控制页面显示与消失 1&lt;span v-else-if&#x3D;&quot;type.prop&#x3D;&#x3D;&#x3D;&#39;tab2&#39;&quot;&gt;选项卡内容2&lt;&#x2F;span&gt; 1.3 from太多内容。。。之后专门总结一篇。 1.4 联网下载下拉选择框用avue的from组件；其中select的配置项里有 dicdata 这个选项，里面填入的是静态的数组，显示出来，把dicdata删掉，换成以下内容： 12\"dicMethod\": \"get\",\"dicUrl\": \"/api/BuildingManage/EditBuilding/getExamineSystem\", 这样就可以实现动态加载下拉选择框的需求了。 2. api文档的编写出现了很多问题，明天需要重写，excel确实不太合适或许考虑使用Markdown？","categories":[],"tags":[{"name":"工作日志","slug":"工作日志","permalink":"http://blog.mrdust.com/tags/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"}]},{"title":"20200413工作日志","slug":"20200413工作日志","date":"2020-04-13T06:42:39.000Z","updated":"2020-04-13T09:55:27.480Z","comments":true,"path":"2020/04/13/20200413工作日志/","link":"","permalink":"http://blog.mrdust.com/2020/04/13/20200413%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/","excerpt":"","text":"20200413工作日志1. 分析火灾风险预警分析系统的系统需求根据需求文档划分功能模块，仔细的如下图： 火灾风险分析预警分析系统 标记了 1 的表示第一阶段做的部分。 2.完成了这三个模块的页面路由编写3.开始写页面3.1 建筑数据采集利用saber自带的表格编辑器，可以做出来。问题不大。 3.2 建筑数据审核 重点 涉及了自定义组件 123456789101112&lt;el-dialog :visible.sync&#x3D;&quot;dialogVisible&quot; append-to-body&gt; &lt;avue-form ref&#x3D;&quot;form&quot; v-model&#x3D;&quot;obj&quot; :option&#x3D;&quot;dialogOption&quot; @reset-change&#x3D;&quot;emptytChange&quot; @submit&#x3D;&quot;submit&quot;&gt; &lt;template slot-scope&#x3D;&quot;scope&quot; slot&#x3D;&quot;menuForm&quot;&gt; &lt;el-button @click&#x3D;&quot;tip&quot;&gt;自定义按钮&lt;&#x2F;el-button&gt; &lt;&#x2F;template&gt; &lt;&#x2F;avue-form&gt;&lt;&#x2F;el-dialog&gt; 其中的avue-form就是个自定义组件，avue写的自定义组件，组件化开发开始出现。 3.3 组件化开发1234567891011&lt;!-- 引用 --&gt;&lt;div class&#x3D;&quot;top-bar__item&quot;&gt; &lt;top-lock&gt;&lt;&#x2F;top-lock&gt;&lt;&#x2F;div&gt;&lt;script&gt;&#x2F;&#x2F;加载方式import topLock from &quot;.&#x2F;top-lock&quot;;components: &#123; topLock&#125;&lt;&#x2F;script&gt; 123456789101112131415161718192021222324252627&lt;!-- 出处 --&gt;&lt;template&gt; &lt;span&gt; &lt;i class&#x3D;&quot;icon-suoping&quot; @click&#x3D;&quot;handleLock&quot;&gt;&lt;&#x2F;i&gt; &lt;el-dialog title&#x3D;&quot;设置锁屏密码&quot; :visible.sync&#x3D;&quot;box&quot; width&#x3D;&quot;30%&quot; append-to-body&gt; &lt;el-form :model&#x3D;&quot;form&quot; ref&#x3D;&quot;form&quot; label-width&#x3D;&quot;80px&quot;&gt; &lt;el-form-item label&#x3D;&quot;锁屏密码&quot; prop&#x3D;&quot;passwd&quot; :rules&#x3D;&quot;[&#123; required: true, message: &#39;锁屏密码不能为空&#39;&#125;]&quot;&gt; &lt;el-input v-model&#x3D;&quot;form.passwd&quot; placeholder&#x3D;&quot;请输入锁屏密码&quot; &#x2F;&gt; &lt;&#x2F;el-form-item&gt; &lt;&#x2F;el-form&gt; &lt;span slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt; &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;handleSetLock&quot;&gt;确 定&lt;&#x2F;el-button&gt; &lt;&#x2F;span&gt; &lt;&#x2F;el-dialog&gt; &lt;&#x2F;span&gt;&lt;&#x2F;template&gt; 略。。。。。","categories":[],"tags":[{"name":"工作日志","slug":"工作日志","permalink":"http://blog.mrdust.com/tags/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"}]},{"title":"20200411工作日志","slug":"20200411工作日志","date":"2020-04-11T01:24:01.000Z","updated":"2020-04-11T03:19:01.775Z","comments":true,"path":"2020/04/11/20200411工作日志/","link":"","permalink":"http://blog.mrdust.com/2020/04/11/20200411%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/","excerpt":"","text":"20200411工作日志1. 基于saber开发，结合mock调通get1.1 页面重开页面获取一个mock的值。 123456789101112131415161718192021222324252627&lt;template&gt; &lt;basic-container&gt; &lt;!--动态加载图片--&gt; &lt;img :src&#x3D;&quot;imgSrcTest&quot; border&#x3D;&quot;0&quot;&gt; &lt;&#x2F;basic-container&gt;&lt;&#x2F;template&gt;&lt;script&gt; import &#123;getImgTest&#125; from &quot;@&#x2F;api&#x2F;test&#x2F;InTest&quot;; export default &#123; name: &quot;getTest&quot;, data() &#123; return &#123; imgSrcTest: &quot;https:&#x2F;&#x2F;cdn4.buysellads.net&#x2F;uu&#x2F;1&#x2F;3386&#x2F;1525189943-38523.png&quot; &#125; &#125;, created() &#123; this.loadingImg(); &#125;, methods:&#123; loadingImg()&#123; getImgTest().then( res &#x3D;&gt; &#123; const data &#x3D; res.data; this.imgSrcTest &#x3D; data.data.img; console.log(this.imgSrcTest); &#125;)&#125;&#125;&#125;&lt;&#x2F;script&gt; 1.2 api1234export const getImgTest = () =&gt; request(&#123; url: \"/getImgTest\", method: 'get',&#125;) 1.3 mock123456789101112function getImgTest() &#123; const json = &#123;code: 200, success: true, msg: '操作成功'&#125;; json.data = &#123; //网上随便找的一张图片的url img: 'https://cdn4.buysellads.net/uu/1/3386/1525189943-38523.png' &#125;; return json;&#125;export default (&#123;mock&#125;) =&gt; &#123; if (!mock) return; Mock.mock(/\\/getImgTest/, 'get', getImgTest);&#125; 2. 基于saber开发，结合mock调通post2.1 页面基于昨天生成的表单页面: 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;basic-container&gt; &lt;h2&gt;post测试&lt;&#x2F;h2&gt; &lt;avue-login :option&#x3D;&quot;option&quot; @submit&#x3D;&quot;submit&quot;&gt; &lt;&#x2F;avue-login&gt; &lt;&#x2F;basic-container&gt;&lt;&#x2F;template&gt;&lt;script&gt; import &#123;postFormTest&#125; from &quot;@&#x2F;api&#x2F;test&#x2F;InTest&quot;; export default &#123; name: &quot;postTest&quot;, data() &#123; return &#123; option: &#123; width: 400, time: 60, codeType: &#39;phone&#39;, &#x2F;&#x2F;phone为手机验证码&#x2F;img为图片验证码 column: &#123; username: &#123; &#x2F;&#x2F; hide: true, label: &#39;用户名&#39;, &#x2F;&#x2F; prop: &#39;user&#39;, &#x2F;&#x2F; placeholder:&#39;&#39;,占位符 autocomplete: &#39;off&#39;, rules: &#123; required: true, message: &#39;请输入用户名&#39;, trigger: &#39;blur&#39; &#125; &#125;, password: &#123; label: &#39;密码&#39;, &#x2F;&#x2F; prop: &#39;pass&#39;, &#x2F;&#x2F; placeholder:&#39;&#39;, autocomplete: &#39;off&#39;, rules: &#123; required: true, message: &#39;请输入密码&#39;, trigger: &#39;blur&#39; &#125; &#125;, code: &#123; hide: true &#125;&#125;&#125;&#125;&#125;, methods: &#123; submit(form) &#123; &#x2F;&#x2F; 直接通过@submit方法自动传入form值，对应表单里的内容， &#x2F;&#x2F; this.$message.success(JSON.stringify(form)); postFormTest(form).then(res &#x3D;&gt; &#123; this.$message.success(res.data.data.msg); &#125;)&#125;&#125;&#125;&lt;&#x2F;script&gt; 2.2 api12345678export const postFormTest = () =&gt; request(&#123; url: \"/postFormTest\", method: 'post', params: &#123; username:\"\", password:\"\" &#125;&#125;) 2.3 mock123456789101112function postFormTest() &#123; const json = &#123;code: 200, success: true, msg: '操作成功'&#125;; json.data = &#123; msg: \"登录成功\" &#125;; return json;&#125;export default (&#123;mock&#125;) =&gt; &#123; if (!mock) return; Mock.mock(/\\/getImgTest/, 'get', getImgTest); Mock.mock(/\\/postFormTest/, 'post', postFormTest);&#125; 3.补充点3.1 Mock.mock()的源码12345678910111213141516171819Mock.mock = function(rurl, rtype, template) &#123; // Mock.mock(template) if (arguments.length === 1) &#123; return Handler.gen(rurl) &#125; // Mock.mock(rurl, template) if (arguments.length === 2) &#123; template = rtype rtype = undefined &#125; // 拦截 XHR if (XHR) window.XMLHttpRequest = XHR Mock._mocked[rurl + (rtype || '')] = &#123; rurl: rurl, rtype: rtype, template: template &#125; return Mock&#125; 传入的三个参数解析： rurl：传入的url rtype：使用的方法（post/get） template: 具体的mock模板，也就是自己写的mock方法。 3.2 通知事务的实现三种方式： 方式 介绍 链接差异 短轮询 Ajax定时任务 定时建立临时链接 长轮询 客户端像传统轮询一样从服务器请求数据。然而，如果服务器没有可以立即返回给客户端的数据，则不会立刻返回一个空结果 建立临时链接，服务器不会立即返回，在链接失效后立即建立链接，重复此过程。 WebSocket 基于Http协议的一个持久化协议 建立一个持久链接，会一直保留，直至网页关闭。","categories":[],"tags":[{"name":"工作日志","slug":"工作日志","permalink":"http://blog.mrdust.com/tags/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"}]},{"title":"2020年04月10日工作日志","slug":"20200410工作日志","date":"2020-04-10T01:31:52.000Z","updated":"2020-04-10T06:54:10.227Z","comments":true,"path":"2020/04/10/20200410工作日志/","link":"","permalink":"http://blog.mrdust.com/2020/04/10/20200410%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/","excerpt":"","text":"2020年04月10日工作日志1. avue Js1.1 简介一个很多骚操作的前端框架让数据驱动视图，减去繁琐的操作，更贴近企业级的前端开发组件 1.2 大表哥（主要的表格控件） image-20200410093854789 点点点自定义表格； 主要特色 复杂表头 表格树 自带分页信息 自带增删改查 自定义弹出表单 支持crud组件全部功能 支持form组件全部功能 1.3 其他功能见 Avue官网2.saber的表单设计类似于magicalcoder的可视化编辑表单设计。生成的是json结构。 2.1实现1—-&gt;使用avue的自定义组件 1234&lt;avue-form ref&#x3D;&quot;form&quot; v-model&#x3D;&quot;obj&quot; :option&#x3D;&quot;option&quot; @reset-change&#x3D;&quot;emptytChange&quot; @submit&#x3D;&quot;submit&quot;&gt; &lt;template slot-scope&#x3D;&quot;scope&quot; slot&#x3D;&quot;menuForm&quot;&gt; &lt;&#x2F;template&gt;&lt;&#x2F;avue-form&gt; 2—-&gt;使用表单生成器生成的json,放入computed中。这部分也可以放入服务器。动态加载表单。 12345678910111213141516171819202122232425262728293031323334353637computed: &#123; option()&#123; return&#123; \"column\": [], \"group\": [ &#123; \"label\": \"登录\", \"prop\": \"1586485337606_31646\", \"column\": [ &#123; \"type\": \"input\", \"label\": \"用户名\", \"span\": 12, \"display\": true, \"prop\": \"1586485358223_39812\", \"required\": true, \"rules\": [ &#123; \"required\": true, \"message\": \"用户名必须填写\" &#125; ] &#125;, &#123; \"type\": \"password\", \"label\": \"密码\", \"span\": 12, \"display\": true, \"prop\": \"1586485454163_45421\", \"rules\": [ &#123; \"required\": true, \"message\": \"密码必须填写\" &#125; ], \"required\": true &#125;]&#125;]&#125;&#125;&#125; 3—-&gt; 效果 image-20200410103422897 没写布局。 2.2 更多详细的使用方法 Avue From3. saber的表格设计3.1 四个表格全局选项 表格配置： 配置主键、提示、序号这一类的表格内容； 操作配置： 可操作的内容 是否可显示、对齐方式等等； 弹窗配置： 表单作为弹窗弹出时的属性； 按钮配置： 除了提交、提交Avue内置了很多自带的按钮。 3.2 实现1—-&gt;新增页面 2—-&gt;Avue的组件 1&lt;avue-crud :data&#x3D;&quot;data&quot; :option&#x3D;&quot;option&quot; v-model&#x3D;&quot;obj&quot; :before-close&#x3D;&quot;beforeOpen&quot;&gt;&lt;&#x2F;avue-crud&gt; 3—-&gt;在saber中设计表格生成json 1234567891011121314&#123; \"column\": [ &#123; \"label\": \"姓名\", \"prop\": \"userName\", \"type\": \"textarea\" &#125;, &#123; \"label\": \"性别\", \"prop\": \"userSex\", \"type\": \"textarea\" &#125; ]&#125; 4—-&gt;在data() 的option中填入生成的json 1234567891011121314option: &#123; \"column\": [ &#123; \"label\": \"姓名\", \"prop\": \"userName\", \"type\": \"textarea\" &#125;, &#123; \"label\": \"性别\", \"prop\": \"userSex\", \"type\": \"textarea\" &#125; ] &#125; 3.3 效果 image-20200410112531897 基础数据显示完成，没有做布局。 4.登录注册4.1 登录页面1—-&gt;Avue自定义组件 12&lt;avue-login :option&#x3D;&quot;option&quot; @submit&#x3D;&quot;submit&quot;&gt;&lt;&#x2F;avue-login&gt; 2—-&gt;配置option 12345678910111213141516171819202122232425option: &#123; width: 400, time: 60, codeType: 'phone', //phone为手机验证码/img为图片验证码 column: &#123; username: &#123; // hide: true, label: '用户名', // prop: 'user', // placeholder:'', autocomplete: 'off', rules: &#123; required: true, message: '请输入用户名', trigger: 'blur' &#125; &#125;, password: &#123; label: '密码', // prop: 'pass', // placeholder:'', autocomplete: 'off', rules: &#123; required: true, message: '请输入密码', trigger: 'blur' &#125; &#125;, code: &#123; hide: true &#125; &#125;&#125; 3—-&gt; 效果 image-20200410143829168 4.2 注册页面配置过程和登录几乎一样。详细在 Avue关于登录。","categories":[],"tags":[{"name":"工作日志","slug":"工作日志","permalink":"http://blog.mrdust.com/tags/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"}]},{"title":"2020年04月09日工作日志","slug":"20200409","date":"2020-04-09T08:07:52.000Z","updated":"2020-04-10T06:54:58.187Z","comments":true,"path":"2020/04/09/20200409/","link":"","permalink":"http://blog.mrdust.com/2020/04/09/20200409/","excerpt":"","text":"saber开发（1）第一个CRUD1.添加新菜单页1—-&gt;新建VUE页面文件 2—-&gt;配置路由 12345678910111213141516&#123; //根路由 path: '/desk', //重定向 redirect: '/desk/test', //组件使用Layout布局 component: Layout, //配置显示多窗口标签页的内容 children: [&#123; path: \"test\", name: \"testPage\", //具体显示的是什么页面。 component: () =&gt; import(/* webpackChunkName: \"views\" */ '@/views/blog/blog') &#125;]&#125; 3—-&gt;在系统里配置页面（菜单管理） image-20200409114908779 新增页面 具体参考《saber开发手册》 2.配置webpack懒加载的代码提示 image-20200409134950695 把webpack的配置文件指向本项目的webpack的配置文件。 3.CURD新增页面的按钮触发一个属性（formVisible）改为true显示dialog，其他出现修改页面的情况相同。新增页面的代码如下： 1234567891011121314151617181920212223242526&lt;el-dialog :title&#x3D;&quot;dialogTitle&quot; width&#x3D;&quot;600px&quot; :visible.sync&#x3D;&quot;formVisible&quot; @close&#x3D;&quot;resetForm(&#39;blogForm&#39;) &quot; append-to-body&gt; &lt;!--append-to-body 解决之前页面全变黑--&gt; &lt;el-form :model&#x3D;&quot;blog&quot; :rules&#x3D;&quot;rules&quot; ref&#x3D;&quot;blogForm&quot;&gt; &lt;el-form-item label&#x3D;&quot;标题&quot; prop&#x3D;&quot;title&quot; label-width&#x3D;&quot;55px&quot;&gt; &lt;el-input v-model&#x3D;&quot;blog.title&quot; autocomplete&#x3D;&quot;off&quot;&gt;&lt;&#x2F;el-input&gt; &lt;&#x2F;el-form-item&gt; &lt;el-form-item label&#x3D;&quot;时间&quot; label-width&#x3D;&quot;55px&quot;&gt; &lt;el-date-picker v-model&#x3D;&quot;blog.time&quot; style&#x3D;&quot;width: 100%;&quot; type&#x3D;&quot;date&quot; value-format&#x3D;&quot;yyyy-MM-dd&quot; placeholder&#x3D;&quot;选择日期&quot; autocomplete&#x3D;&quot;off&quot;&gt; &lt;&#x2F;el-date-picker&gt; &lt;&#x2F;el-form-item&gt; &lt;el-form-item label&#x3D;&quot;内容&quot; label-width&#x3D;&quot;55px&quot;&gt; &lt;el-input v-model&#x3D;&quot;blog.content&quot; autocomplete&#x3D;&quot;off&quot; type&#x3D;&quot;textarea&quot; :rows&#x3D;&quot;5&quot;&gt;&lt;&#x2F;el-input&gt; &lt;&#x2F;el-form-item&gt; &lt;&#x2F;el-form&gt; &lt;div slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt; &lt;el-button @click&#x3D;&quot;formVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt; &lt;el-button v-if&#x3D;&quot;viewMode&quot; type&#x3D;&quot;primary&quot; @click&#x3D;&quot;submitBlog(&#39;blogForm&#39;)&quot;&gt;确 定&lt;&#x2F;el-button&gt; &lt;&#x2F;div&gt; &lt;&#x2F;el-dialog&gt; 显示不同的dialog可以使用两种方式控制： 1： dialog的固定属性 例如：title、width、fullscreen、top等等详细参看element的开发文档。在触发这个dialog的方法中赋值，实现dialog代码的复用。 2： 运用Vue指令 v-if 在触发dialog的方法中控制v-if中的状态码。 以下为实现了CURD的不同实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647handleAdd() &#123; this.formVisible = true; this.dialogTitle = \"新增博客\"; this.viewMode = true;&#125;,handleView(index, row) &#123; this.formVisible = true; this.dialogTitle = \"查看博客\"; this.viewMode = false; getDetail(row.id).then(res =&gt; &#123; if (res.data.success) &#123; this.blog = res.data.data; &#125; &#125;)&#125;,handleEdit(index, row) &#123; this.formVisible = true; this.dialogTitle = \"编辑博客\"; this.viewMode = true; getDetail(row.id).then(res =&gt; &#123; if (res.data.success) &#123; this.blog = res.data.data; &#125; &#125;)&#125;,handleDelete(index, row) &#123; this.$confirm(\"确定将选择数据删除?\", &#123; confirmButtonText: \"确定\", cancelButtonText: \"取消\", type: \"warning\" &#125;).then(() =&gt; &#123; remove(row.id).then(res =&gt; &#123; if (res.data.success) &#123; this.onLoad(); this.$message(&#123; type: 'success', message: '操作成功！' &#125;) &#125; else &#123; this.$message(&#123; type: 'error', message: res.data.msg &#125;) &#125; &#125;); &#125;);&#125;, 4.批量删除4.1Computed当其依赖的属性的值发生变化时，计算属性会重新计算，反之，则使用缓存中的属性值。 4.2 Computed代码123456789computed: &#123; ids() &#123; let ids = []; this.multiSelection.forEach(ele =&gt; &#123; ids.push(ele.id); &#125;); return ids.join(\",\"); &#125;&#125;, 定义了一个computed方法ids，其中需要遍历的属性是let ids，其中multiSelection是多选栏的数组，遍历以后返回ids得以遍历ids。 4.3实现批量删除多选框： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;el-table :data&#x3D;&quot;data&quot; @selection-change&#x3D;&quot;selectChange&quot; style&#x3D;&quot;width: 100%&quot;&gt; &lt;!-- 第一行是用来控制多选 --&gt; &lt;el-table-column prop&#x3D;&quot;id&quot; type&#x3D;&quot;selection&quot; width&#x3D;&quot;55&quot;&gt; &lt;&#x2F;el-table-column&gt; &lt;el-table-column prop&#x3D;&quot;title&quot; label&#x3D;&quot;标题&quot; width&#x3D;&quot;180&quot;&gt; &lt;&#x2F;el-table-column&gt; &lt;el-table-column prop&#x3D;&quot;content&quot; label&#x3D;&quot;内容&quot;&gt; &lt;&#x2F;el-table-column&gt; &lt;el-table-column prop&#x3D;&quot;time&quot; label&#x3D;&quot;日期&quot; width&#x3D;&quot;180&quot;&gt; &lt;&#x2F;el-table-column&gt; &lt;el-table-column label&#x3D;&quot;操作&quot; fixed&#x3D;&quot;right&quot; width&#x3D;&quot;250&quot;&gt; &lt;template slot-scope&#x3D;&quot;scope&quot;&gt; &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;&quot; plain @click&#x3D;&quot;handleView(scope.$index, scope.row)&quot;&gt;查看 &lt;&#x2F;el-button&gt; &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;primary&quot; plain @click&#x3D;&quot;handleEdit(scope.$index, scope.row)&quot;&gt;编辑 &lt;&#x2F;el-button&gt; &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;danger&quot; @click&#x3D;&quot;handleDelete(scope.$index, scope.row)&quot;&gt;删除 &lt;&#x2F;el-button&gt; &lt;&#x2F;template&gt; &lt;&#x2F;el-table-column&gt;&lt;&#x2F;el-table&gt; 逻辑控制： 12345678910111213141516171819202122232425262728handleMultiDelete() &#123; console.log(\"multi-delete\"); //multiSelection这是选中的id的数组 if (this.multiSelection.length === 0) &#123; this.$message.warning(\"请选择至少一条数据\"); return; &#125; this.$confirm(\"确定将选择数据删除?\", &#123; confirmButtonText: \"确定\", cancelButtonText: \"取消\", type: \"warning\" &#125;).then(() =&gt; &#123; remove(this.ids).then(res =&gt; &#123; if (res.data.success) &#123; this.onLoad(); this.$message(&#123; type: 'success', message: '操作成功！' &#125;) &#125; else &#123; this.$message(&#123; type: 'error', message: res.data.msg &#125;) &#125; &#125;); &#125;);&#125;,","categories":[],"tags":[{"name":"工作日志","slug":"工作日志","permalink":"http://blog.mrdust.com/tags/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"}]},{"title":"2020年04月08日工作日志","slug":"20200408","date":"2020-04-08T08:07:52.000Z","updated":"2020-04-09T08:06:20.042Z","comments":true,"path":"2020/04/08/20200408/","link":"","permalink":"http://blog.mrdust.com/2020/04/08/20200408/","excerpt":"","text":"1.风险火调需求文档1.1 做黄线以后的部分1.2 共四个人做，我主要负责前端2. Spring Blade 微服务开发平台 采用前后端分离的模式，前端开源两个框架：Sword (基于 React、Ant Design)、Saber (基于 Vue、Element-UI) 后端采用SpringCloud全家桶，并同时对其基础组件做了高度的封装，单独开源出一个框架：BladeTool BladeTool已推送至Maven中央库，直接引入即可，减少了工程的臃肿，也可更注重于业务开发 集成Sentinel从流量控制、熔断降级、系统负载等多个维度保护服务的稳定性。 注册中心、配置中心选型Nacos，为工程瘦身的同时加强各模块之间的联动。 使用Traefik进行反向代理，监听后台变化自动化应用新的配置文件。 极简封装了多租户底层，用更少的代码换来拓展性更强的SaaS多租户系统。 借鉴OAuth2，实现了多终端认证系统，可控制子系统的token权限互相隔离。 借鉴Security，封装了Secure模块，采用JWT做Token认证，可拓展集成Redis等细颗粒度控制方案。 稳定生产了一年，经历了从Camden -&gt; Greenwich的技术架构，也经历了从fat jar -&gt; docker -&gt; k8s + jenkins的部署架构 项目分包明确，规范微服务的开发模式，使包与包之间的分工清晰。 3. bladex-boot(Spring Blade 后端)4. Saber (Spring Blade的前端)4.1 简介SpringBlade前端UI项目，对现有的avue2.0、element-ui库进行二次封装。基于json驱动的模块配置，打造最好用的vuejs中后台脚手架。 4.2 实现了第一页功能主要流程和Vue原生开发差不多。主要是组件，路由实现。 4.3 疑问没有数据库文件。 4.4 配置mock 在相应的mock配置文件中写&lt;test.js&gt; mock的数据： 12345function getFakeDetail() &#123; const json = &#123;code:200,success:true,msg:\"操作成功\"&#125;; json.data = \"测试返回\"; return json;&#125; 默认执行的方法： 1234export default (&#123;mock&#125;) =&gt; &#123; if (!mock) return; Mock.mock(/\\/api\\/demo\\/detail/,'get',getFakeDetail)&#125; 在index.js中配置每一个mock。mock是否开启模拟数据拦截 1test(&#123;mock: true&#125;) 4.5 配置API4.5.1 自定义API这是一个接口API： 123456export const getDetail = () =&gt;&#123; return request(&#123; url: '/api/demo/detail', method: 'get', &#125;)&#125; 4.5.2同步访问API mock文件，注意！ rurl的格式 123456789101112131415function getFakeDetail() &#123; const json = &#123;code:200,success:true,msg:\"操作成功\"&#125;; json.data = \"测试返回\"; return json;&#125;function getFakeTestDetail() &#123; const json = &#123;code:200,success:true,msg:\"操作成功\"&#125;; json.data = \"测试Test返回\"; return json;&#125;export default (&#123;mock&#125;) =&gt; &#123; if (!mock) return; Mock.mock(/\\/api\\/demo\\/detail/,'get',getFakeDetail); Mock.mock(/\\/api\\/demo\\/test-detail/,'get',getFakeTestDetail)&#125; API接口 123456789101112export const getDetail = () =&gt;&#123; return request(&#123; url: '/api/demo/detail', method: 'get', &#125;)&#125;export const getTestDetail = () =&gt;&#123; return request(&#123; url: '/api/demo/test-detail', method: 'get', &#125;)&#125; 测试页面： 1234567891011121314151617181920created() &#123; const ar = this.init(); console.log(ar);&#125;,methods: &#123; async init() &#123; const res = await getDetail(); if (res.data.success)&#123; console.log(res.data.data); &#125;else &#123; console.log(res.data.msg); &#125; const resTest = await getTestDetail(); if (resTest.data.success)&#123; console.log(resTest.data.data); &#125;else &#123; console.log(resTest.data.msg); &#125; &#125;&#125;","categories":[],"tags":[{"name":"工作日志","slug":"工作日志","permalink":"http://blog.mrdust.com/tags/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"}]},{"title":"Vue.js学习笔记.VueX运用","slug":"vueX","date":"2019-11-11T11:57:52.000Z","updated":"2019-11-11T12:37:55.087Z","comments":true,"path":"2019/11/11/vueX/","link":"","permalink":"http://blog.mrdust.com/2019/11/11/vueX/","excerpt":"","text":"Vue.js学习笔记.VueX运用安装，导入安装： 1npm install vuex --save 导入项目：（基于element-starter） main.js 12345678910111213import Vue from 'vue'import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'import App from './App.vue'import store from './vuex/store.js' //导入store文件Vue.prototype.$SURL = 'http://127.0.0.1:8099';new Vue(&#123; store, el: '#app', render: h =&gt; h(App)&#125;) store.js 123456789101112import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)//存放对象const state = &#123;&#125;//存放方法const mutations = &#123;&#125;export default new Vuex.Store(&#123; state, mutations&#125;) 准备完毕！ 写入，读取数据读写数据操作写在mutations里； 以方法的形式写入； 12345const mutations = &#123; setUser(state, n)&#123; return (state.user = n) &#125;&#125; 读取的方法： 12在html中直接读取&#123;&#123;$store.state.count&#125;&#125; 操作可以在各种方法中加入计算属性，不过不要加太多，毕竟这是前端。 现在把VueX用于存储用户登录信息，方便记录用户的操作，在服务器形成日志。 可以大量页面之间需要共同应用的变量，就比如用户对象，表单对象。 就这么简单！","categories":[],"tags":[{"name":"Vue.Js Vuex","slug":"Vue-Js-Vuex","permalink":"http://blog.mrdust.com/tags/Vue-Js-Vuex/"}]},{"title":"10月30日就业知识讲座(萍乡学院音乐厅)","slug":"1030就业讲座","date":"2019-10-30T13:33:36.000Z","updated":"2019-10-30T15:00:23.508Z","comments":true,"path":"2019/10/30/1030就业讲座/","link":"","permalink":"http://blog.mrdust.com/2019/10/30/1030%E5%B0%B1%E4%B8%9A%E8%AE%B2%E5%BA%A7/","excerpt":"","text":"10月30日就业知识讲座 10月30日晚上本来是就业指导课，接到通知，有位来自链家（上海）的就业指导老师来学校开讲座，刚开始抱着随便听一听的态度听了下，后来发现 有点东西。也没带记录本啥的，回宿舍赶紧记下来，可能会不完整。 1.职业生涯规划1.1职业道路规划 生活和工作是不可能分开的。 行业发展：对整个行业的大体认知，例如发展方向，发展潜力，技能需求变化等等。 个人发展：对自己的审视，自身性格，自己当前阶段的需求，自身身体情况。 职业生涯发展：在工作中学习会遇到一些瓶颈，在提升自己的同时，难免会遇到转岗的问题，例如从技术岗转管理，此时对自身的专业技能要求高的同时还要求拥有相应的管理能力。那之前的知识储备就显得相当重要。 1.2职业“燃料” 职场“燃料”会不断的消耗。 不断学习的重要性。 在做好自身职业的道路规划后，有目的的去学习，去实践，为自己不断注入燃料。 2.简历之前参加了一次招聘会，临时做了一份自以为还可以的简历，现在回想还是太年轻。考虑准备多份简历。 2.1简历模板 基本信息 –姓名，年龄，性别，居住地，联系方式，求职意向（城市/行业/岗位） 教育经历 –学校，学历，专业，课程，成绩 //其中可以加入自学科目体现自学能力 个人经历 –校招：校园活动，兼职经历，实习经历 –获得的奖项表彰荣誉：竞赛，导师，科研，论文，期刊，奖学金 –技能：IT，语言能力，专业证书等。（软件行业应附上掌握相应技能） 2.2简历的注意事项 篇幅一页，排版简洁，重点突出，文字精炼，无格式错误 –基本信息不能少：姓名，手机号，邮箱 –就业意向：城市，行业，岗位 –教育经历：两行概述（不超过三分之一） –实习经历：简历一半以上篇幅 万能公式： 时间段+主要个人工作内容+工作成绩数据化总结（工作结束后上级评价+个人总结） 2.3多份简历的作用对于应聘不同岗位，不同行业来说需要不同的简历。同时不同公司的同一岗位也会因为各种原因导致要求不一样，所以对于不同的公司，有余力的话应该准备不同的简历。 3.面试3.1面试流程3.1.1开场双手递交简历，认真听面试官指令； 3.1.2自我介绍您好，我叫***（时间控制在30秒–1分钟）； 3.1.3面试问答面试官提问环节； 3.1.4面试官答题向面试官咨询2–3个问题； 3.1.5结束注意些细节，例如出去关门啥的。 3.2自我介绍 自我介绍的唯一标准：让人印象深刻 3.2.1目标明确推销自己要达成的目的。 我是来找工作的，我能为公司解决什么问题，我能为公司创造什么，我以后能为公司创造什么。 3.2.2能做什么有哪些让你脱颖而出的技能和成就。 3.2.3解决问题你能为公司做些什么或是带来什么。 3.2.4取得成绩你在现在或是在过去的工作岗位上取得的成果。 3.3面试问答押题：1.自我介绍： 学历，兴趣，成长背景等； 2.我的优缺点： 应避免只是已条例式的列举方式来说明，可以适当加入小故事来强化自己谈话内容的真实性；在说明自己的缺点时，如果能附带改进之道，会让主面感受到应征者积极主动的特质。 3.生涯规划： 针对所应征的职位提出时间表，如三年内让自己在基层工作学习，并配合公司的升迁制度，在企业内成长。 4.待遇问题： 对新人来说，不知道是最好的答案。（我以为，应该符合公司在招聘时贴出的薪酬） 5.公司吸引我的地方： 根据自己收集的有关公司的资料，运用自己的话题，诚恳的说明动机。 3.4面试官答题绝对不会出错的几个问题： 1.我在工作中将会遇到什么挑战； 2.公司的发展前景，以及自己在网上尚未查到的信息； 3.在公司对自己的提高。 4.感想 收获颇多吧，希望能在明年春季招聘中找到适合自己的一份工作。加油！奥利给！！！","categories":[],"tags":[{"name":"讲座；就业","slug":"讲座；就业","permalink":"http://blog.mrdust.com/tags/%E8%AE%B2%E5%BA%A7%EF%BC%9B%E5%B0%B1%E4%B8%9A/"}]},{"title":"算法-1- 栈的快速排序","slug":"算法-1-栈快速排序","date":"2019-09-26T08:23:52.000Z","updated":"2019-09-26T08:32:17.689Z","comments":true,"path":"2019/09/26/算法-1-栈快速排序/","link":"","permalink":"http://blog.mrdust.com/2019/09/26/%E7%AE%97%E6%B3%95-1-%E6%A0%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","excerpt":"","text":"栈的快速排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//循环实现public class QuickStack &#123; /* * @Parm 要排序的对象 * @Return void * * 输出模块 * * */ public static void print(int[] arr)&#123; for(int n=0;n&lt;arr.length;n++)&#123; System.out.print(arr[n]+\" \"); &#125; System.out.println(); &#125; /* * @parm 需要排序的对象；栈底；栈顶 * @return void * * 用来实现对快速排序 退栈排序再入栈， * */ public static void fun(int[] a, int low, int high)&#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); if(low &lt; high)&#123; stack.add(low); stack.add(high); while(!stack.isEmpty())&#123; int hi = stack.pop();//pop删除栈顶的对象返回此对象 int lo = stack.pop(); int key = partition(a, lo, hi); if(lo &lt; key-1)&#123; stack.push(lo); stack.push(key-1); &#125; if(hi &gt; key)&#123; stack.push(key+1); stack.push(hi);//这样，最后入栈的就是key右边的部分，则下一次循环先处理key右边的部分 &#125; &#125; &#125; &#125; /* * @Parm 要排序的对象；栈低，同时也是快速排序的“标杆”;栈顶 * @Return 返回\"标杆\" 同时打印此次排序以后的栈的情况； * * 快速排序的soul!!! * */ public static int partition(int[] a, int low, int high)&#123; int key = a[low]; while(low&lt;high)&#123; while(a[high]&gt;=key&amp;&amp;low&lt;high)&#123;//大于等于key的数组元素不需要移动 high--; &#125; a[low] = a[high]; while(a[low]&lt;=key&amp;&amp;low&lt;high)&#123;//小于于等于key的数组元素不需要移动 low++; &#125; a[high] = a[low]; &#125; a[low] = key; print(a); return low; &#125; public static void main(String[] args) &#123; int[] arr = &#123;49,38,65,97,76,13,27,49,55,4&#125;; fun(arr, 0, arr.length-1); &#125;&#125;","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://blog.mrdust.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Vue.Js 第五天--布局容器","slug":"Vue.Js 第五天--布局容器","date":"2019-09-24T01:40:52.000Z","updated":"2019-09-26T08:30:23.358Z","comments":true,"path":"2019/09/24/Vue.Js 第五天--布局容器/","link":"","permalink":"http://blog.mrdust.com/2019/09/24/Vue.Js%20%E7%AC%AC%E4%BA%94%E5%A4%A9--%E5%B8%83%E5%B1%80%E5%AE%B9%E5%99%A8/","excerpt":"","text":"Vue.Js 第五天–布局容器element的网页基础布局用于布局的容器组件，方便快速搭建页面的基本结构： &lt;el-container&gt;：外层容器。当子元素中包含 &lt;el-header&gt; 或 &lt;el-footer&gt; 时，全部子元素会垂直上下排列，否则会水平左右排列。 &lt;el-header&gt;：顶栏容器。 &lt;el-aside&gt;：侧边栏容器。 &lt;el-main&gt;：主要区域容器。 &lt;el-footer&gt;：底栏容器。 以上全部支持flex 布局(弹性布局) ,&lt;el-container&gt; 的子元素只能是后四者，后四者的父元素也只能是 &lt;el-container&gt;。 Container Attributes 参数 说明 类型 可选值 默认值 direction 子元素的排列方向 string horizontal (水平)/ vertical(垂直) 子元素中有 el-header 或 el-footer 时为 vertical，否则为 horizontal Header Attributes 参数 说明 类型 可选值 默认值 height 顶栏高度 string — 60px Aside Attributes 参数 说明 类型 可选值 默认值 width 侧边栏宽度 string — 300px Footer Attributes 参数 说明 类型 可选值 默认值 height 底栏高度 string — 60px 这些都不是必须加的.是根布局.","categories":[],"tags":[{"name":"Vue.Js","slug":"Vue-Js","permalink":"http://blog.mrdust.com/tags/Vue-Js/"}]},{"title":"Vue.Js 第四天--layout布局","slug":"Vue.Js 第四天","date":"2019-09-23T10:53:52.000Z","updated":"2019-09-26T08:30:18.107Z","comments":true,"path":"2019/09/23/Vue.Js 第四天/","link":"","permalink":"http://blog.mrdust.com/2019/09/23/Vue.Js%20%E7%AC%AC%E5%9B%9B%E5%A4%A9/","excerpt":"","text":"Vue.Js 第四天–layout布局前置技能row 行概念 12&lt;el-row span = \"24\"&gt;&lt;/el-row&gt;&lt;!--这就是占全部的写法--&gt; col 列概念 12&lt;el-col span=\"12\"&gt;&lt;/el-col&gt;&lt;!--这就是占一半的写法--&gt; layout布局就是一行分成24格,这样便于布局.用span来控制占多少格. 实现混合布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;el-row &gt; &lt;!-- col是列 row是列 --&gt; &lt;el-row &gt; &lt;el-col :span&#x3D;&quot;24&quot;&gt; &lt;div class&#x3D;&quot;grid-content bg-purple-dark&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;el-col&gt; &lt;&#x2F;el-row&gt; &lt;el-row :gutter&#x3D;&quot;10&quot;&gt; &lt;el-col :span&#x3D;&quot;8&quot;&gt; &lt;div class&#x3D;&quot;grid-content bg-purple&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;el-col&gt; &lt;el-col :span&#x3D;&quot;8&quot;&gt; &lt;div class&#x3D;&quot;grid-content bg-purple-light&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;el-col&gt; &lt;el-col :span&#x3D;&quot;8&quot;&gt; &lt;div class&#x3D;&quot;grid-content bg-purple&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;el-col&gt; &lt;&#x2F;el-row&gt; &lt;el-row&gt; &lt;el-col :span&#x3D;&quot;6&quot;&gt; &lt;div class&#x3D;&quot;grid-content bg-purple&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;el-col&gt; &lt;el-col :span&#x3D;&quot;6&quot;&gt; &lt;div class&#x3D;&quot;grid-content bg-purple-light&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;el-col&gt; &lt;el-col :span&#x3D;&quot;6&quot;&gt; &lt;div class&#x3D;&quot;grid-content bg-purple&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;el-col&gt; &lt;el-col :span&#x3D;&quot;6&quot;&gt; &lt;div class&#x3D;&quot;grid-content bg-purple-light&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;el-col&gt; &lt;&#x2F;el-row&gt; &lt;el-row&gt; &lt;el-col :span&#x3D;&quot;4&quot;&gt; &lt;div class&#x3D;&quot;grid-content bg-purple&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;el-col&gt; &lt;el-col :span&#x3D;&quot;4&quot;&gt; &lt;div class&#x3D;&quot;grid-content bg-purple-light&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;el-col&gt; &lt;el-col :span&#x3D;&quot;4&quot;&gt; &lt;div class&#x3D;&quot;grid-content bg-purple&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;el-col&gt; &lt;el-col :span&#x3D;&quot;4&quot;&gt; &lt;div class&#x3D;&quot;grid-content bg-purple-light&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;el-col&gt; &lt;el-col :span&#x3D;&quot;4&quot;&gt; &lt;div class&#x3D;&quot;grid-content bg-purple&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;el-col&gt; &lt;el-col :span&#x3D;&quot;4&quot;&gt; &lt;div class&#x3D;&quot;grid-content bg-purple-light&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;el-col&gt; &lt;&#x2F;el-row&gt; &lt;el-col :xs&#x3D;&quot;4&quot; :sm&#x3D;&quot;6&quot; :md&#x3D;&quot;4&quot; :lg&#x3D;&quot;3&quot; :xl&#x3D;&quot;1&quot;&gt; &lt;el-form&gt; &lt;el-button @click&#x3D;&quot;onc&quot;&gt;didi&lt;&#x2F;el-button&gt; &lt;&#x2F;el-form&gt; &lt;&#x2F;el-col&gt; &lt;&#x2F;el-row&gt; Col Attributes 参数 说明 类型 可选值 默认值 span 栅格占据的列数 number — 24 offset 栅格左侧的间隔格数 number — 0 push 栅格向右移动格数 number — 0 pull 栅格向左移动格数 number — 0 xs &lt;768px 响应式栅格数或者栅格属性对象 number/object (例如： {span: 4, offset: 4}) — — sm ≥768px 响应式栅格数或者栅格属性对象 number/object (例如： {span: 4, offset: 4}) — — md ≥992px 响应式栅格数或者栅格属性对象 number/object (例如： {span: 4, offset: 4}) — — lg ≥1200px 响应式栅格数或者栅格属性对象 number/object (例如： {span: 4, offset: 4}) — — xl ≥1920px 响应式栅格数或者栅格属性对象 number/object (例如： {span: 4, offset: 4}) — — tag 自定义元素标签 string * div xs,sm,md,lg,xl是参照了 Bootstrap 的 响应式设计尺寸. span是实现24layout布局的比例分割. offset实现中间间隔. Row Attributes 参数 说明 类型 可选值 默认值 gutter 栅格间隔 number — 0 type 布局模式，可选 flex，现代浏览器下有效 string — — justify flex 布局下的水平排列方式 string start/end/center/space-around/space-between start align flex 布局下的垂直排列方式 string top/middle/bottom top tag 自定义元素标签 string * div gutter每一个单位 大小是 0.5px,","categories":[],"tags":[{"name":"Vue.Js","slug":"Vue-Js","permalink":"http://blog.mrdust.com/tags/Vue-Js/"}]},{"title":"Vue.Js 第三天--element基础搭建","slug":"Vue.Js 第三天--element基础搭建","date":"2019-09-22T08:03:52.000Z","updated":"2019-09-26T08:30:12.383Z","comments":true,"path":"2019/09/22/Vue.Js 第三天--element基础搭建/","link":"","permalink":"http://blog.mrdust.com/2019/09/22/Vue.Js%20%E7%AC%AC%E4%B8%89%E5%A4%A9--element%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA/","excerpt":"","text":"Vue.Js 第三天–element基础搭建1.安装npm i element-ui -S 安装element 2.建立element 的index.js文件index.js文件 12345import Vue from 'vue'import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'Vue.use(ElementUI) 引入main.js,即可正常使用. 3.写页面login.vue页面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;template&gt; &lt;el-row type=\"flex\" justify=\"center\"&gt; &lt;el-form ref=\"loginForm\" :model=\"user\" :rules=\"rules\" status-icon label-width=\"80px\"&gt;&lt;!--ref用于form调用login方法 :model数据对象 :rules 启用数据验证 status-icon 显示状态图标--&gt; &lt;el-form-item label=\"用户名\" prop=\"name\"&gt; &lt;!--el-form-item一个表单组 prop元素名 --&gt; &lt;el-input v-model=\"user.name\"&gt;&lt;/el-input&gt; &lt;!--v-model指令 输入的是user对象的name属性--&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"密码\" prop=\"pass\"&gt; &lt;el-input v-model=\"user.pass\" type=\"password\"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=\"primary\" icon=\"el-icon-upload\" @click=\"login\"&gt;登录&lt;/el-button&gt; &lt;!--@click调用login方法 --&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/el-row&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; login () &#123; this.$refs.loginForm.validate((valid) =&gt; &#123; if (valid) &#123; if (this.user.name === 'admin' &amp;&amp; this.user.pass === '123') &#123; this.$notify(&#123; type: 'success', message: '欢迎你,' + this.user.name + '!', duration: 3000 &#125;) this.$router.replace('/') &#125; else &#123; this.$message(&#123; type: 'error', message: '用户名或密码错误', showClose: true &#125;) &#125; &#125; else &#123; return false &#125; &#125;) &#125; &#125;, data () &#123; return &#123; user: &#123;&#125;, rules: &#123; name: [ &#123;required: true, message: '用户名不能为空', trigger: 'blur'&#125; ], pass: [ &#123;required: true, message: '密码不能为空', trigger: 'blur'&#125; ] &#125; &#125; &#125; &#125;&lt;/script&gt; 4.总结js验证很重要,深度了解element组件很重要.","categories":[],"tags":[{"name":"Vue.Js","slug":"Vue-Js","permalink":"http://blog.mrdust.com/tags/Vue-Js/"}]},{"title":"Vue.Js 第二天","slug":"Vue.Js 第二天","date":"2019-09-16T08:07:52.000Z","updated":"2019-09-26T08:30:06.120Z","comments":true,"path":"2019/09/16/Vue.Js 第二天/","link":"","permalink":"http://blog.mrdust.com/2019/09/16/Vue.Js%20%E7%AC%AC%E4%BA%8C%E5%A4%A9/","excerpt":"","text":"Vue.Js 第二天1.模板语法2.1指令指令 (Directives) 是带有 v- 前缀的特殊特性。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 2.1.1指令的参数一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，v-bind 指令可以用于响应式地更新 HTML 特性： 1&lt;a v-bind:href=\"url\"&gt;...&lt;/a&gt; 在这里 href 是参数，告知 v-bind 指令将该元素的 href 特性与表达式 url 的值绑定。 另一个例子是 v-on 指令，它用于监听 DOM 事件： 1&lt;a v-on:click=\"doSomething\"&gt;...&lt;/a&gt;/* 相当于是加载不同的方法*/ 动态的设置一些值 2.1.2动态参数从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数： 1&lt;a v-bind:[attributeName]&#x3D;&quot;url&quot;&gt; ... &lt;&#x2F;a&gt; 这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 data 属性 attributeName，其值为 &quot;href&quot;，那么这个绑定将等价于 v-bind:href。 同样地，你可以使用动态参数为一个动态的事件名绑定处理函数： 1&lt;a v-on:[eventName]=\"doSomething\"&gt; ... &lt;/a&gt; 同样地，当 eventName 的值为 &quot;focus&quot; 时，v-on:[eventName] 将等价于 v-on:focus。 动态参数预期会求出一个字符串，异常情况下值为 null。这个特殊的 null 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。 ​ 属性的键可变 2.1.3修饰符修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()： 1&lt;form v-on:submit.prevent=\"onSubmit\"&gt;...&lt;/form&gt; submit调用prevent方法。修饰符就是让submit（属性）调用其他方法。 2.1.3缩写v-bind 缩写 v-bind 动态地绑定一个或多个特性、或一个组件 prop 到表达式。 12345&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=\"url\"&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=\"url\"&gt;...&lt;/a&gt; v-on 缩写 v-on 监听DOM事件 形式如：v-on:click 缩写为 @click; 12345&lt;!-- 完整语法 --&gt;&lt;a v-on:click=\"doSomething\"&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=\"doSomething\"&gt;...&lt;/a&gt; 常用的两个用法","categories":[],"tags":[{"name":"Vue.Js","slug":"Vue-Js","permalink":"http://blog.mrdust.com/tags/Vue-Js/"}]},{"title":"Vue.Js 第一天","slug":"Vue.Js 第一天","date":"2019-09-15T01:07:52.000Z","updated":"2019-09-26T08:30:29.732Z","comments":true,"path":"2019/09/15/Vue.Js 第一天/","link":"","permalink":"http://blog.mrdust.com/2019/09/15/Vue.Js%20%E7%AC%AC%E4%B8%80%E5%A4%A9/","excerpt":"","text":"Vue.Js 第一天1.模板语法核心Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。 &lt; !– more –&gt; 1.1插入值1.1.1插入文本数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值： 1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; Mustache 标签将会被替代为对应数据对象上 msg 属性的值。无论何时，绑定的数据对象上 msg属性发生了改变，插值处的内容都会更新。 通过使用 [v-once 指令]，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定： 1&lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;/span&gt; (双大括号可实现数据随时刷新,v-once 是一次性数据绑定) 1.1.2插入HTML双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html指令： 12&lt;p&gt;Using mustaches: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;&lt;p&gt;Using v-html directive: &lt;span v-html=\"rawHtml\"&gt;&lt;/span&gt;&lt;/p&gt; 这个 span 的内容将会被替换成为属性值 rawHtml，直接作为 HTML——会忽略解析属性值中的数据绑定。注意，你不能使用 v-html 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。反之，对于用户界面 (UI)，组件更适合作为可重用和可组合的基本单位。 用v-html来实现输出HTML,可被浏览器解析,不安全 1.1.3插入JavaScript表达式迄今为止，在我们的模板中，我们一直都只绑定简单的属性键值。但实际上，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。 1234567&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;div v-bind:id=\"'list-' + id\"&gt;&lt;/div&gt; 这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。 12345&lt;!-- 这是语句，不是表达式 --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 在一段JavaScript表达式里只能绑定一个数据,考虑使用三元表达式或者分开写 1.2指令指令是 带 v-前缀的代码,指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 1.2.1参数","categories":[],"tags":[{"name":"Vue.Js","slug":"Vue-Js","permalink":"http://blog.mrdust.com/tags/Vue-Js/"}]}],"categories":[],"tags":[{"name":"工作日志","slug":"工作日志","permalink":"http://blog.mrdust.com/tags/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"},{"name":"Vue.Js Vuex","slug":"Vue-Js-Vuex","permalink":"http://blog.mrdust.com/tags/Vue-Js-Vuex/"},{"name":"讲座；就业","slug":"讲座；就业","permalink":"http://blog.mrdust.com/tags/%E8%AE%B2%E5%BA%A7%EF%BC%9B%E5%B0%B1%E4%B8%9A/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://blog.mrdust.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Vue.Js","slug":"Vue-Js","permalink":"http://blog.mrdust.com/tags/Vue-Js/"}]}